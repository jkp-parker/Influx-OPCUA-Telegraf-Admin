from typing import List, Dict, Any


def generate_config(
    devices: List[Any],
    system_config: Dict[str, str],
) -> str:
    """Generate a Telegraf configuration file from device and tag data."""

    config_path = system_config.get("telegraf_config_path", "/etc/telegraf/telegraf.conf")
    influxdb_url = system_config.get("influxdb_url", "http://localhost:8086")
    influxdb_token = system_config.get("influxdb_token", "$INFLUX_TOKEN")
    influxdb_org = system_config.get("influxdb_org", "myorg")
    influxdb_default_bucket = system_config.get("influxdb_default_bucket", "default")
    app_title = system_config.get("app_title", "FluxForge")

    lines = []
    lines.append(f"# Telegraf Configuration")
    lines.append(f"# Generated by {app_title}")
    lines.append(f"# Config path: {config_path}")
    lines.append("")

    lines.append("[agent]")
    lines.append('  interval = "10s"')
    lines.append("  round_interval = true")
    lines.append("  metric_batch_size = 1000")
    lines.append("  metric_buffer_limit = 10000")
    lines.append('  collection_jitter = "0s"')
    lines.append('  flush_interval = "10s"')
    lines.append('  flush_jitter = "0s"')
    lines.append('  precision = ""')
    lines.append('  hostname = ""')
    lines.append("  omit_hostname = false")
    lines.append("")

    # Collect all unique InfluxDB targets
    influx_targets: Dict[int, Any] = {}
    for device in devices:
        if not device.enabled:
            continue
        if device.influxdb_config:
            cfg = device.influxdb_config
            influx_targets[cfg.id] = cfg

    if not influx_targets:
        # Use system-level defaults
        lines.append("[[outputs.influxdb_v2]]")
        lines.append(f'  urls = ["{influxdb_url}"]')
        lines.append(f'  token = "{influxdb_token}"')
        lines.append(f'  organization = "{influxdb_org}"')
        lines.append(f'  bucket = "{influxdb_default_bucket}"')
        lines.append("")
    else:
        for cfg in influx_targets.values():
            lines.append("[[outputs.influxdb_v2]]")
            lines.append(f'  urls = ["{cfg.url}"]')
            lines.append(f'  token = "{cfg.token}"')
            lines.append(f'  organization = "{cfg.org}"')
            lines.append(f'  bucket = "{cfg.bucket}"')
            lines.append("")

    # OPC UA inputs per device
    for device in devices:
        if not device.enabled:
            continue

        enabled_tags = [t for t in device.tags if t.enabled]
        if not enabled_tags:
            continue

        # Group tags by scan class
        by_scan_class: Dict[str, List[Any]] = {}
        for tag in enabled_tags:
            sc_name = tag.scan_class.name if tag.scan_class else "default"
            by_scan_class.setdefault(sc_name, []).append(tag)

        for sc_name, tags in by_scan_class.items():
            interval_ms = 1000
            if tags[0].scan_class:
                interval_ms = tags[0].scan_class.interval_ms
            interval_str = _ms_to_duration(interval_ms)

            lines.append("[[inputs.opcua]]")
            safe_name = device.name.replace(" ", "_")
            lines.append(f'  name = "{safe_name}_{sc_name}"')
            lines.append(f'  endpoint = "{device.endpoint_url}"')
            if device.username:
                lines.append(f'  username = "{device.username}"')
                lines.append(f'  password = "{device.password}"')
            if device.security_policy and device.security_policy != "None":
                lines.append(f'  security_policy = "{device.security_policy}"')
            lines.append(f'  interval = "{interval_str}"')
            lines.append('  connect_fail_behavior = "ignore"')
            lines.append("")

            for tag in tags:
                measurement = tag.measurement_name or safe_name
                lines.append("  [[inputs.opcua.nodes]]")
                lines.append(f'    name = "{tag.display_name.replace(" ", "_")}"')
                lines.append(f'    namespace = "{tag.namespace}"')
                lines.append(f'    identifier_type = "{tag.identifier_type}"')
                lines.append(f'    identifier = "{tag.identifier}"')
                lines.append(f'    tags = {{measurement = "{measurement}", scanClass = "{sc_name}"}}{chr(10)}')

        lines.append("")

    return "\n".join(lines)


def _ms_to_duration(ms: int) -> str:
    if ms < 1000:
        return f"{ms}ms"
    seconds = ms // 1000
    if seconds < 60:
        return f"{seconds}s"
    minutes = seconds // 60
    if minutes < 60:
        return f"{minutes}m"
    hours = minutes // 60
    return f"{hours}h"
